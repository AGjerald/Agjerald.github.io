<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Anders Finnebråten Gjerald - Interaksjonsdesigner</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Domine:wght@400..700&display=swap" rel="stylesheet">
  <!-- Koble til separat CSS-fil -->
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <!-- YTTERKANT / RAMME -->
  <div class="page">
    <!-- TOPP-NAV -->
    <header class="site-header">
      <nav class="nav">
        <a href="index.html">Home</a>
        <a href="index.html#portfolio">Portfolio</a>
        <a href="#contact.html">Contact</a>
      </nav>
    </header>
    <main class="grid">
        <section class="hero" 
            style="--hero-image: url('images/cue_pose.png'); --hero-opacity:0.8;">
            <h1 class="hero_inset"><span class="accent">Project</span> | Cue - Figma prototype</h1>
            <ul class="project_tools" aria-label="Technologies used" role="list" style="padding-left: 5vw">
                <li>Figma</li>
            </ul>
        </section>

        <section id="project_site" class="project_site card">
            <h2>The project</h2>
            <p> <i>"Cue"</i> was a student group project carried out as part of the MIX202 course at the University of Bergen. 
                The prototype aimed to create a tool to support individuals struggling with social interaction and everyday tasks. 
                It introduced multiple search methods—sketch, pose, text, and speech—to ensure accessibility and inclusivity through universal design. 
                In addition, the prototype featured mini-games that allowed users to practice and experience common social interactions in daily life. 
                The design and user experience were intentionally kept simple to better serve people with disabilities or social anxiety.
            </p>
            <p>
                The project was based on an assignment that required us to explore video retrieval technology—a method for retrieving media, such as videos or images, from a predefined database. 
                This technology relies on searches conducted through text or speech-to-text input. 
                We aimed to apply this concept to a real-world scenario, which ultimately led to the creation of Cue—an interactive tool designed to help users practice social cues.
            </p>
            <p>Check out the prototype! <a href="https://www.figma.com/proto/EhBsDKueoREaZWGqrFPzvV/Cue?node-id=728-3417&p=f&t=Uxp2kKbyF0rU6HkO-1&scaling=scale-down&content-scaling=fixed&page-id=1%3A2166&starting-point-node-id=232%3A2311" target="_blank" rel="noopener noreferrer">here!</a></p>
        </section>

    <section id="project_site" class="project_site card">
    <h2>Snippets from the prototype</h2>

    <div class="slideshow" aria-label="Project screenshots">
        <div class="slides" data-index="0">
        <figure class="slide">
            <img src="images/Sketch search 3.svg" alt="Landingpage with hero and CTA" loading="lazy">
            <figcaption>Sketch search enabing users to search by sektches.</figcaption>
        </figure>

        <figure class="slide">
            <img src="images/recognizefeatures_main3.svg" alt="About page layout with timeline" loading="lazy">
            <figcaption>Minigame to practice recognition of body language.</figcaption>
        </figure>

        <figure class="slide">
            <img src="images/Scenario_ Make an order 1.svg" alt="Contact form and map embed" loading="lazy">
            <figcaption>Full Motion Video game to practice real life scenarios.</figcaption>
        </figure>

        <figure class="slide">
            <img src="images/Practice_main.svg" alt="Contact form and map embed" loading="lazy">
            <figcaption>"Your goals" sub page where the user can choose which goals to practice.</figcaption>
        </figure>
        </div>
        

        <button class="nav prev" aria-label="Previous slide">‹</button>
        <button class="nav next" aria-label="Next slide">›</button>

        <div class="dots" role="tablist" aria-label="Slide navigation">
        <button role="tab" aria-selected="true" tabindex="0" aria-controls="slide-1"></button>
        <button role="tab" aria-selected="false" tabindex="-1" aria-controls="slide-2"></button>
        <button role="tab" aria-selected="false" tabindex="-1" aria-controls="slide-3"></button>
        </div>
    </div>
    </section>


    </main>
    <footer class="tiny">
        <p>© <span id="y"></span> Anders Finnebråten Gjerald — All rights reserved.</p>
    </footer>

    <script>
        (function initSlideshow(root = document.querySelector('#project_site .slideshow')) {
        if (!root) return;

        const track = root.querySelector('.slides');
        const slides = [...root.querySelectorAll('.slide')];
        const prevBtn = root.querySelector('.prev');
        const nextBtn = root.querySelector('.next');
        const dotsWrap = root.querySelector('.dots');

        // Lag dots dynamisk basert på faktiske slides
        dotsWrap.innerHTML = '';
        const dots = slides.map((_, i) => {
            const b = document.createElement('button');
            b.type = 'button';
            b.setAttribute('role', 'tab');
            b.setAttribute('aria-controls', `slide-${i+1}`);
            b.tabIndex = i === 0 ? 0 : -1;
            b.setAttribute('aria-selected', i === 0 ? 'true' : 'false');
            dotsWrap.appendChild(b);
            return b;
        });

        let index = 0;
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const setIndex = (i, {focusDot=false} = {}) => {
            index = clamp(i, 0, slides.length - 1);
            track.style.transform = `translateX(${-index * 100}%)`;
            dots.forEach((d, idx) => {
            const sel = idx === index;
            d.setAttribute('aria-selected', sel ? 'true' : 'false');
            d.tabIndex = sel ? 0 : -1;
            if (sel && focusDot) d.focus();
            });
        };

        prevBtn.addEventListener('click', () => setIndex(index - 1, {focusDot:true}));
        nextBtn.addEventListener('click', () => setIndex(index + 1, {focusDot:true}));

        dots.forEach((dot, i) => {
            dot.addEventListener('click', () => setIndex(i, {focusDot:true}));
            dot.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') setIndex(i + 1, {focusDot:true});
            if (e.key === 'ArrowLeft')  setIndex(i - 1, {focusDot:true});
            });
        });

        // Swipe
        let startX = null, lastX = null, isDragging = false;
        const start = (x) => { startX = lastX = x; isDragging = true; track.style.transition = 'none'; };
        const move  = (x) => { if (!isDragging) return; lastX = x; const dx = x - startX; track.style.transform = `translateX(${(-index*100) + (dx / root.clientWidth)*100}%)`; };
        const end   = () => {
            if (!isDragging) return;
            const dx = lastX - startX;
            track.style.transition = '';
            if (Math.abs(dx) > root.clientWidth * 0.2) setIndex(index + (dx < 0 ? 1 : -1));
            else setIndex(index);
            isDragging = false; startX = lastX = null;
        };

        track.addEventListener('pointerdown', e => { track.setPointerCapture(e.pointerId); start(e.clientX); });
        track.addEventListener('pointermove', e => move(e.clientX));
        track.addEventListener('pointerup', end);
        track.addEventListener('pointercancel', end);
        track.addEventListener('pointerleave', () => isDragging && end());

        setIndex(0);
        })();
    </script>
</body>
</html>



